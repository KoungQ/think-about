# 왜 Linux는 MLFQ 대신 CFS를 선택했는가

운영체제 스케줄링을 공부하다 질문이 생겼다.

MLFQ는 현실적인 스케줄링 기법으로 평가받는데 왜 Linux는 MLFQ가 아니라 CFS를 선택했을까?

이 질문에 답하려면 MLFQ가 잘하는 것과 Linux가 실제로 풀어야 했던 문제가 무엇이었는지를 같이 봐야 한다.

---

### MLFQ는 무엇을 잘했는가

MLFQ는 미래 실행 시간을 알 수 없는 현실을 전제로 한다.

그래서 과거 행동을 보고 프로세스의 성격을 추측한다.

- CPU를 짧게 쓰면 대화형 작업
- CPU를 오래 쓰면 CPU-bound 작업

이 방식 덕분에

- 대화형 작업의 응답 시간은 좋고
- CPU-bound 작업도 완전히 굶지는 않는다

단일 CPU 환경이나 단순한 워크로드에서는 꽤 훌륭한 선택이었다.

---

### 하지만 MLFQ의 한계는 명확했다

MLFQ는 점점 복잡해진다.

공정성을 유지하려면

- 우선순위 하향 규칙
- 우선순위 상향 boost
- CPU 사용 시간 누적
- 스케줄러 조작 방지 로직

같은 규칙이 계속 추가된다.

결국 문제는 MLFQ는 휴리스틱 기반이라는 것이다.  
잘 동작하길 기대하는 방식이지 정확히 얼마나 CPU를 쓰게 될지는 예측하기 어렵다.

---

### Linux가 마주한 현실적인 문제

Linux는 단순한 교육용 OS가 아니다.

- 수백 개 이상의 프로세스
- 멀티코어 환경
- 서버 워크로드
- 사용자별 공정성
- 장시간 실행되는 시스템

이 환경에서 중요한 건  누가 빨리 끝나느냐보다 **누가 얼마나 공정하게 CPU를 쓰느냐**였다.

즉 응답 시간 최적화보다 CPU 사용 비율을 명확히 제어하는 문제가 더 중요해졌다.

---

### CFS의 핵심 관점

CFS와 MLFQ는 질문 자체가 다르다.

- **MLFQ**

    이 프로세스는 짧은 작업일까 긴 작업일까

- **CFS**

  이 프로세스는 지금까지 CPU를 얼마나 덜 썼는가

그래서 CFS는 실행 시간을 추측하지 않는다.  
대신 실제로 쓴 시간을 기준으로 판단한다.

---

### CFS의 기본 아이디어

모든 프로세스가 마치 이상적인 멀티태스킹 환경에서 동시에 조금씩 실행되는 것처럼 보이게 하자.

이를 위해 CFS는

- 가상 실행 시간 virtual runtime을 유지한다.
- CPU를 덜 쓴 프로세스를 먼저 실행한다.
- 우선순위는 가중치로 표현된다.

결과적으로

- 특정 프로세스가 CPU를 독점하기 어렵고
- 장기적으로 매우 안정적인 공정성이 유지된다.

---

### 왜 MLFQ보다 CFS가 Linux에 적합했는가

정리하면 이유는 명확하다.

- MLFQ는 규칙 기반 휴리스틱이다.
- CFS는 실행 시간 기반의 수학적 모델에 가깝다.

Linux는

- 수많은 프로세스
- 긴 실행 시간
- 서버와 데스크톱을 모두 커버해야 하는 환경

에서 응답 시간 튜닝보다 일관된 공정성과 예측 가능성을 더 중요하게 선택했다.

요약하자면, MLFQ는 미래를 모르기 때문에 과거를 추측했고 CFS는 미래를 묻지 않고 지금까지의 사실만 본다.

그래서 Linux는 MLFQ 대신 CFS를 선택했다.


