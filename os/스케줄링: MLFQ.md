# MLFQ (Multi Level Feedback Queue)

### 왜 MLFQ가 필요했을까

CPU 스케줄링에서 가장 이상적인 알고리즘으로 자주 언급되는 것은 SJF 계열이다.  
실행 시간이 짧은 작업을 먼저 실행하면 평균 반환 시간이 최소가 되기 때문이다.

하지만 이 방식에는 치명적인 전제가 하나 있다.  
운영체제가 각 작업의 실행 시간을 미리 알고 있어야 한다는 점이다.

현실에서는 이 전제가 성립하지 않는다.

- 프로그램이 앞으로 CPU를 얼마나 사용할지 알 수 없고,
- 실행 도중 성격이 바뀌기도 하며
- 사용자 입력이나 I O에 따라 실행 패턴이 계속 달라진다.

RR은 응답 시간과 공정성은 좋지만 CPU bound 작업이 많아지면 반환 시간이 급격히 나빠진다.

결국 현실의 운영체제는 미래를 정확히 아는 스케줄링 대신 현실적인 타협이 필요했다.

그 결과로 등장한 방식이 MLFQ다.

---

### 핵심 아이디어는 과거를 본다

MLFQ는 미래를 예측하지 않는다.  
대신 프로세스가 지금까지 어떻게 행동했는지를 기준으로 판단한다.

운영체제는 실행 중인 프로세스를 관찰하면서 다음과 같은 식으로 성격을 추측한다.

- CPU를 짧게 사용하고 자주 양보한다  
  → 대화형 작업일 가능성이 높다.
- CPU를 오래 점유한다.  
  → CPU bound 작업일 가능성이 높다.

즉, MLFQ는 과거의 실행 패턴을 기반으로 SJF를 흉내 내려는 전략이다.

---

### MLFQ의 기본 구조

MLFQ는 하나의 큐로 구성되지 않는다.

- 여러 개의 큐가 존재한다.
- 각 큐는 서로 다른 우선순위를 가진다.
- 스케줄러는 항상 가장 높은 우선순위 큐를 먼저 확인한다.
- 같은 큐 안에서는 보통 RR 방식으로 실행된다.

이 구조 덕분에 우선순위 기반 스케줄링과 시분할 스케줄링이 결합된다.

---

### 기본 동작 방식

MLFQ의 동작 규칙은 단순하지만 의도가 분명하다.

1. 새 프로세스는 항상 최상위 큐에서 시작한다.  
   처음에는 모든 작업을 짧은 작업이라고 가정한다.

2. 할당된 CPU 시간을 끝까지 사용하면 우선순위가 내려간다.  
   CPU를 오래 쓸수록 점점 아래 큐로 이동한다.

3. I/O 등으로 CPU를 일찍 양보하면 우선순위를 유지한다.  
   대화형 작업은 높은 우선순위를 계속 유지한다.

이 규칙을 통해 프로세스는 실행될수록 자신의 성격에 맞는 큐로 이동하게 된다.

---

### MLFQ가 만들어내는 효과

이 방식은 자연스럽게 다음과 같은 결과를 만든다.

대화형 작업은 항상 높은 우선순위 큐에서 빠르게 실행된다.  
그래서 응답 시간이 좋아진다.

CPU bound 작업은 점점 아래 큐로 내려간다.  
응답은 느릴 수 있지만 CPU를 완전히 빼앗기지는 않는다.

결과적으로 MLFQ는 응답 시간과 공정성 사이의 현실적인 균형을 맞춘다.

---

### MLFQ의 한계

MLFQ는 현실적인 해법이지만 완벽하지는 않다.

첫 번째 문제는 **기아**다.  
대화형 작업이 계속 많아지면 아래 큐에 있는 CPU bound 작업이 실행되지 못할 수 있다.

두 번째 문제는 **스케줄러 조작 가능성**이다.  
타임 슬라이스가 끝나기 직전에 일부러 I O를 호출하면 긴 작업임에도 짧은 작업처럼 보일 수 있다.

이는 한 번에 사용한 CPU 시간만 보고 판단하기 때문에 발생한다.

세 번째 문제는 프로세스 성격 변화다.  
처음에는 CPU bound였던 작업이 나중에는 대화형 작업으로 바뀔 수도 있다.

하지만 과거 행동만 보고 성격을 고정하면 이 변화를 반영하지 못한다.

---

### 보완 기법

이런 문제를 완화하기 위해 MLFQ에는 몇 가지 보완 규칙이 추가된다.

우선순위 상향 boost는 일정 시간마다 모든 프로세스를 최상위 큐로 올린다.  
이를 통해 기아를 방지하고 프로세스 성격 변화를 다시 평가할 수 있다.

CPU 사용 시간 누적 기준은 한 번에 얼마나 썼는지가 아니라 지금까지 총 얼마나 썼는지를 기준으로 판단한다.

이를 통해 스케줄러를 속이는 행위를 줄일 수 있다.

---

### 정리

MLFQ는 이론적으로 완벽한 스케줄링 알고리즘은 아니다.

하지만
- 미래를 알 수 없는 현실을 전제로 하고
- 응답 시간과 공정성 사이에서 타협하며
- 실제 운영체제에 적용 가능한 구조를 가진다.

그래서 MLFQ는 현실적인 운영체제 스케줄링의 대표적인 해법으로 사용된다.
