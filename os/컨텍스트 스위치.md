# 컨텍스트 스위치

### 컨텍스트 스위치란?

컨텍스트 스위치(Context Switch)는 CPU(또는 코어)에서 실행 중이던 **프로세스/스레드가 다른 프로세스/스레드로 교체되는 것**을 의미한다.

오늘날 컴퓨터에서 **CPU가 직접 실행하는 기본 단위는 스레드**다.  
그래서 "프로세스가 바뀐다"는 말은 엄밀히 말하면

- 어떤 프로세스 안에서 실행되던 스레드가
- 다른 프로세스 안에서 실행되던 스레드로

바뀌는 상황을 의미한다.

다만 서로 다른 프로세스에 속한 스레드가 교체되는 경우를 일반적으로  
**프로세스 컨텍스트 스위치**라고 부른다.

---

### 컨텍스트(context)란?

컨텍스트는 프로세스 혹은 스레드의 **상태(state)** 를 말한다.  
여기서 상태란 크게 두 가지다.

- CPU 상태
- 메모리 상태

특히 CPU 상태는 레지스터 값들의 집합이다.

- Program Counter (PC)
- Stack Pointer (SP)
- 그 외 여러 레지스터

컨텍스트 스위치가 발생하면 운영체제는 현재 실행 흐름의 레지스터 상태를 저장하고, 다음 실행 흐름의 레지스터 상태를 복원해서 이어서 실행한다.

---

### 컨텍스트 스위치는 왜 필요한가?

컨텍스트 스위치는 멀티태스킹을 위해 필요하다.

CPU는 하나인데 여러 프로세스/스레드를 **동시에** 실행하는 것처럼 보이게 하려면 짧은 시간 단위로 CPU를 번갈아 할당해야 한다.

이때 실행 대상을 바꾸는 순간이 컨텍스트 스위치다.

---

### 컨텍스트 스위치는 언제 발생하는가?

대표적으로 다음 상황에서 발생한다.

- 타임 슬라이스(퀀텀)를 다 사용했을 때
- I/O 작업을 하러 가야 할 때 (Blocked)
- 다른 프로세스/스레드가 점유 중인 리소스를 기다려야 할 때
- 인터럽트가 발생했을 때

---

### 멀티태스킹에서의 컨텍스트 스위치 흐름

CPU 타임을 아주 짧은 타임 슬라이스로 쪼개고, 프로세스들이 그 시간을 번갈아 사용한다.

- P1 실행 (짧은 시간)
- 컨텍스트 스위치
- P2 실행 (짧은 시간)
- 컨텍스트 스위치
- 다시 P1 실행

이렇게 번갈아 실행되기 때문에 사용자는 여러 프로그램이 동시에 실행되는 것처럼 느낀다.

---

### 컨텍스트 스위치는 누가 실행하는가?

컨텍스트 스위치는 운영체제의 **커널(kernel)** 이 수행한다.


- 프로세스/스레드는 CPU에서 실행되다가
- 어떤 사건(타이머, 시스템 콜, I/O 등)으로 커널에게 제어권을 넘기고
- 커널이 저장/복원/스케줄링을 수행한다.

즉, 컨텍스트 스위치는 **커널 모드에서** 실행된다.

---

### 두 종류의 컨텍스트 스위치

컨텍스트 스위치는 크게 두 가지로 나눌 수 있다.

- **프로세스 컨텍스트 스위치**  
  서로 다른 프로세스에 속한 스레드로 교체되는 경우

- **스레드 컨텍스트 스위치**  
  같은 프로세스 내부에서 스레드끼리 교체되는 경우

두 경우 모두 공통적으로 레지스터 상태를 교체한다.

---

### 공통점: 커널 모드 + 레지스터 상태 교체

컨텍스트 스위치의 공통점은 다음 두 가지다.

- 커널 모드에서 실행된다.
- CPU 레지스터 상태를 저장하고 복원한다.

왜 저장하냐면, 그래야 나중에 다시 돌아왔을 때 "어디까지 실행했는지"를 복원하고 이어서 실행할 수 있기 때문이다.

---

### 차이점: 메모리 주소 체계를 바꾸는가?

스레드 컨텍스트 스위치는 같은 프로세스 내부에서 일어난다.  
즉, 스레드들이 같은 주소 공간(메모리 영역)을 공유한다.

그래서 스레드 스위치는

- 레지스터 저장/복원만 하면 끝난다

반면 프로세스 컨텍스트 스위치는 서로 다른 프로세스 간 전환이다.  
프로세스마다 **가상 메모리 주소 체계가 다르다.**

그래서 프로세스 스위치는 레지스터 교체 외에도

- MMU가 바라보는 주소 체계를 새 프로세스로 바꿔야 하고
- TLB(주소 변환 캐시)를 비워야 한다.

이 **메모리 주소 체계 처리**가 추가되기 때문에  
프로세스 컨텍스트 스위치는 더 느리다.

---

### 스레드 컨텍스트 스위치가 더 빠른 이유

정리하면 이렇다.

- 스레드는 같은 프로세스의 주소 공간을 공유한다.
- 그래서 메모리 주소 체계를 바꿀 필요가 없다.
- CPU 레지스터 상태만 교체하면 된다.

따라서 스레드 컨텍스트 스위치는 프로세스 컨텍스트 스위치보다 가볍고 빠르다.

---

### 컨텍스트 스위치의 간접 비용: 캐시 오염(Cache Pollution)

컨텍스트 스위치는 레지스터/주소 체계 비용만 있는 게 아니다.

CPU에는 캐시가 있다.  
자주 쓰는 데이터를 캐시에 올려서 메모리 접근을 줄이는 장치다.

하지만 컨텍스트 스위치가 일어나면 새로 실행되는 대상은 기존 캐시 데이터를 거의 쓸 수 없다.

- 같은 프로세스 내 스레드 전환이라면  
  메모리를 공유하므로 캐시 재사용 가능성이 조금 있다

- 다른 프로세스 전환이라면  
  메모리를 공유하지 않으므로 캐시 재사용 가능성이 더 낮다

그래서 컨텍스트 스위치 직후에는 캐시 미스가 늘고, 결국 메모리 접근이 증가해 성능이 떨어진다.

---

### 컨텍스트 스위치는 오버헤드다

애플리케이션 관점에서 컨텍스트 스위치는 내 프로그램의 일을 하는 시간이 아니라

- 저장하고
- 바꾸고
- 복원하고
- 다시 시작하는

순수한 관리 비용(오버헤드)이다.

그래서 컨텍스트 스위치가 너무 자주 발생하면 시스템 성능은 나빠진다.

---

### 정리

- 컨텍스트 스위치는 실행 대상을 바꾸는 작업이다
- CPU는 스레드를 실행하므로, 프로세스 스위치도 결국 스레드 교체다
- 스레드 스위치는 레지스터 교체 중심이라 빠르다
- 프로세스 스위치는 주소 체계(MMU/TLB) 처리까지 필요해 느리다
- 캐시 오염 때문에 간접 비용도 발생한다
- 컨텍스트 스위치는 애플리케이션 입장에서 오버헤드다
