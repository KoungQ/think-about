## 상속 메모리 구조

---

### 상속이란?

기존 클래스의 필드와 메서드를 새로운 클래스에서 **재사용**하게 해주는 프로그래밍 요소이다.  
`extends` 키워드를 사용하며, 단 하나의 클래스로부터만 상속할 수 있다.

- **부모 클래스 (Super Class)** : 필드와 메서드를 **제공**하는 클래스
- **자식 클래스 (Sub Class)** : 부모 클래스로부터 필드와 메서드를 **상속**받는 클래스

---

### 상속 메모리 구조

`Child child = new Child();` 로 객체를 생성하면,  
Heap에는 `Parent` 영역과 `Child` 영역이 함께 생성되고 Stack에는 참조 변수가 저장된다.

```text
    [Stack]                              [Heap]
┌────────────┐              ┌──────────────────────────────┐
│ x001       │ ───────────▶ │        x001 (Object)         │
│ child      │              │ ┌──────────────────────────┐ │
└────────────┘              │ │  Parent (Super Class)    │ │
                            │ │  + methodA()             │ │
                            │ ├──────────────────────────┤ │
                            │ │  Child (Sub Class)       │ │
                            │ │  + methodB()             │ │
                            │ └──────────────────────────┘ │
                            └──────────────────────────────┘
```
---
### Q. 어떤 클래스를 기준으로 메서드가 호출될까?
A. 호출하는 변수의 타입(클래스)을 기준으로 메서드를 탐색한다.
1. 자신의 타입(`Child`)에서 먼저 찾는다.
2. 없다면 부모 타입(`Parent`)에서 찾는다.
3. 그래도 없으면 컴파일 에러 발생.


>Example 1. `child.methodA()` 호출
> 1. `Child` 클래스에서 `methodA()` 탐색
> 2. 없음 → `Parent` 클래스에서 탐색
> 3. `methodA()` 발견 → 호출 성공
>
> Example 2. `child.methodB()` 호출
> 1. `Child` 클래스에서 `methodB()` 탐색
> 2. `methodB()` 발견 → 호출 성공
>
> Example 3. `child.methodC()` 호출
> 1. `Child` 클래스에서 `methodC()` 탐색
> 2. 없음 → `Parent` 클래스에서도 없음
> 3. 없음 → 컴파일 에러 발생

---
### 정리
- 상속된 객체는 Heap 내부에서 부모와 자식의 영역이 함께 존재한다.
- 메서드 호출 시에는 참조 변수의 타입을 기준으로 검색이 시작된다.
- 현재 타입에서 없으면 상위 부모 클래스로 올라가며, 끝까지 없으면 컴파일 오류가 발생한다.