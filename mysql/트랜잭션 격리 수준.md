# 트랜잭션 격리 수준

### 트랜잭션이란?
트랜잭션은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다. <br>
데이터의 일관성을 유지하면서 안정적으로 데이터를 복구하기 위해 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위로 Commit 되거나 Rollback 되어야 한다.

--- 

### ANSI SQL 트랜잭션 격리 수준

- READ UNCOMMITTED

    커밋하지 않은 데이터 조차도 접근할 수 있는 격리 수준
    트랜잭션 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 Dirty Read가 발생 가능함
    따라서 심각한 정합성 문제가 발생하기 때문에 일반적으로 사용하지 않음

      Dirty Read

      트랜잭션으로 아직 존재할 수 없는 데이터가 조회되는 것
      즉 다른 트랜잭션이 아직 커밋하지 않은 데이터를 읽어버리는 현상
    
- READ COMMITTED
    
    커밋이 완료된 데이터만 접근 가능한 격리 수준
    다른 트랜잭션의 커밋 여부에 따라 조회 결과가 달라지는 Non-Repeatable Read 발생

      Non-Repeatable Read
      
      예를 들어 트랜잭션 A와 B가 있다고 가정하자.
      먼저 트랜잭션 A가 시작되었다. A는 특정 레코드를 조회하고 a라는 결과를 받았다.
      그리고 트랜잭션 A가 종료되기 전, 트랜잭션 B가 실행되었고 레코드의 값을 b로 바꾼 뒤 종료되었다.
      이때 트랜잭션 A가 다시 레코드를 조회하면 b라는 결과를 받게 된다.
      
      한 트랜잭션이 같은 쿼리를 두 번 이상 실행했을 때, 그 사이에 다른 트랜잭션이 데이터를 수정하면 결과가 달라지는 현상
    
    
- REPEATABLE READ
    
    한 트랜잭션 내에서 동일한 쿼리를 여러번 실행해도 같은 데이터가 나오는 것을 보장하는 격리 수준
    하지만 새로운 레코드 추가 자체를 막는 것이 아니므로 Phantom Read가 발생
    
    MySQL, InnoDB에서 기본 수준으로 채택 (하지만 Phantom Read는 차이가 존재함)

      Phantom Read
    
      존재할 수 있는 데이터긴 하나 해당 트랜잭션의 시점이 아닌 것
      즉 새로 삽입되는 데이터는 한 트랜잭션에서 같은 쿼리를 실행하더라도 조회가 되는 현상

- SERIALIZABLE
    
    모든 트랜잭션을 순차적으로 처리시키며 가장 엄격한 격리 수준
    따라서 동시 처리 성능이 매우 떨어지지만 여러 트랜잭션에 동일 레코드 동시 접근이 어려우므로 어떠한 데이터 부정합도 발생하지 않음
    순수 SELECT에서도 Next Key Lock을 읽기 잠금으로 걸기 때문에 타 트랜잭션에서는 절대 추가/수정/삭제가 불가능함

---

### MySQL 트랜잭션 격리 수준
MySQL(InnoDB)은 MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)를 사용하여 트랜잭션 간의 충돌을 최소화하면서도 일관성을 보장한다.
즉, 각 트랜잭션은 자신이 시작된 시점의 데이터를 스냅샷으로 읽기 때문에, 다른 트랜잭션이 데이터를 수정하더라도 바로 영향을 받지 않는다.<br>
이러한 구조로 인해 MySQL의 REPEATABLE READ 격리 수준은 ANSI SQL 표준과 약간의 차이를 보인다.
표준에서는 Phantom Read가 발생할 수 있지만, MySQL에서는 Next-Key Lock(넥스트 키 락)과 Gap Lock(갭 락)을 이용해 Phantom Read가 발생하지 않도록 보장한다.


- REPEATABLE READ 동작 방식

  InnoDB는 데이터가 변경되면 그 이전 버전을 언두 로그(Undo Log)에 저장한다. <br>
트랜잭션이 데이터를 조회할 때, 자신보다 이후에 시작된 트랜잭션이 수정한 데이터가 있다면
언두 로그에 저장된 이전 버전을 읽는다. <br>
즉, 트랜잭션 A가 시작된 뒤 트랜잭션 B가 데이터를 변경하고 커밋하더라도,
트랜잭션 A는 트랜잭션이 시작된 시점의 스냅샷을 그대로 유지한다.
따라서 동일한 쿼리를 여러 번 실행해도 항상 같은 결과를 얻는다. <br>
이로 인해 REPEATABLE READ는 Dirty Read와 Non-Repeatable Read를 완벽히 방지한다.
다만 새로운 행의 추가(INSERT)는 별개의 문제이기 때문에,
이론적으로는 팬텀 리드가 발생할 여지가 남는다.

      Gap Lock(갭 락)
  
      레코드 자체가 아닌, 레코드와 레코드 사이의 틈에 락을 거는 방식이다.
      새로운 레코드가 그 틈에 삽입되는 것을 방지하여 동일한 조건의 SELECT 결과가 바뀌지 않도록 한다.
  
      Next-Key Lock(넥스트 키 락)
  
      실제 레코드 락(Row Lock)과 Gap Lock이 결합된 형태로, "레코드 자신 + 바로 앞의 간격"을 잠근다.
      따라서 특정 범위 내의 레코드 추가, 수정, 삭제 모두 차단되어 Phantom Read가 발생하지 않는다.

  이 때문에 MySQL에서는 REPEATABLE READ임에도 불구하고, 사실상 SERIALIZABLE에 가까운 수준의 정합성을 제공한다.


- SERIALIZABLE과의 차이

  하지만 SERIALIZABLE 수준과 완전히 동일한 것은 아니다.<br>
  REPEATABLE READ는 MVCC를 기반으로 스냅샷을 읽기 때문에, SELECT 쿼리가 다른 트랜잭션을 블로킹하지 않는다.<br>
  반면 SERIALIZABLE은 모든 SELECT조차 공유 락(Shared Lock)을 걸어버리므로, 다른 트랜잭션이 데이터를 추가하거나 수정하는 행위 자체가 불가능하다.
  따라서 그만큼 데이터 일관성은 높지만, 동시성(Concurrency)은 크게 떨어진다.