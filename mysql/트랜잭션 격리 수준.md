# 트랜잭션 격리 수준

### 트랜잭션이란?
트랜잭션은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.

데이터의 일관성을 유지하면서 안정적으로 데이터를 복구하기 위해 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위로 Commit 되거나 Rollback 되어야 한다.

--- 

### ANSI SQL 트랜잭션 격리 수준

- READ UNCOMMITTED

    커밋하지 않은 데이터 조차도 접근할 수 있는 격리 수준
    트랜잭션 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 Dirty Read가 발생 가능함
    따라서 심각한 정합성 문제가 발생하기 때문에 일반적으로 사용하지 않음

      Dirty Read

      트랜잭션으로 아직 존재할 수 없는 데이터가 조회되는 것
      즉 다른 트랜잭션이 아직 커밋하지 않은 데이터를 읽어버리는 현상
    
- READ COMMITTED
    
    커밋이 완료된 데이터만 접근 가능한 격리 수준
    다른 트랜잭션의 커밋 여부에 따라 조회 결과가 달라지는 Non-Repeatable Read 발생

      Non-Repeatable Read
      
      예를 들어 트랜잭션 A와 B가 있다고 가정하자.
      먼저 트랜잭션 A가 시작되었다. A는 특정 레코드를 조회하고 a라는 결과를 받았다.
      그리고 트랜잭션 A가 종료되기 전, 트랜잭션 B가 실행되었고 레코드의 값을 b로 바꾼 뒤 종료되었다.
      이때 트랜잭션 A가 다시 레코드를 조회하면 b라는 결과를 받게 된다.
      
      한 트랜잭션이 같은 쿼리를 두 번 이상 실행했을 때, 그 사이에 다른 트랜잭션이 데이터를 수정하면 결과가 달라지는 현상
    
    
- REPEATABLE READ
    
    한 트랜잭션 내에서 동일한 쿼리를 여러번 실행해도 같은 데이터가 나오는 것을 보장하는 격리 수준
    하지만 새로운 레코드 추가 자체를 막는 것이 아니므로 Phantom Read가 발생
    
    MySQL, InnoDB에서 기본 수준으로 채택 (하지만 Phantom Read는 차이가 존재함)

      Phantom Read
    
      존재할 수 있는 데이터긴 하나 해당 트랜잭션의 시점이 아닌 것
      즉 새로 삽입되는 데이터는 한 트랜잭션에서 같은 쿼리를 실행하더라도 조회가 되는 현상

- SERIALIZABLE
    
    모든 트랜잭션을 순차적으로 처리시키며 가장 엄격한 격리 수준
    따라서 동시 처리 성능이 매우 떨어지지만 여러 트랜잭션에 동일 레코드 동시 접근이 어려우므로 어떠한 데이터 부정합도 발생하지 않음
    순수 SELECT에서도 Next Key Lock을 읽기 잠금으로 걸기 때문에 타 트랜잭션에서는 절대 추가/수정/삭제가 불가능함

---

### MySQL 트랜잭션 격리 수준
ANSI SQL 표준 격리 수준들과 가장 차이점이 발생하는 지점은 REPEATABLE READ 이다.

